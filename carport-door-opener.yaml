---
substitutions:
  system_name: carport-door-opener
  friendly_name: "Carport Door Opener"
  device_description: NodeMCU-based garage door controller

esp8266:
  restore_from_flash: true

packages:
  device: !include
    file: esp8266/base.yaml

# configuration
globals:
  - id: performing_last_movement
    type: boolean
    restore_value: false
    initial_value: "false"

switch:
  - platform: gpio
    id: garage_door_relay
    pin: D1
    inverted: true
    restore_mode: ALWAYS_OFF
    internal: true
    on_turn_on:
      - delay: 500ms
      - switch.turn_off: garage_door_relay

binary_sensor:
  - platform: gpio
    id: open_endstop
    name: "Open Endstop"
    device_class: garage_door
    internal: true
    pin:
      number: D3
      mode: INPUT_PULLUP
    filters:
      - invert:
      - delayed_on: 1000ms # Wait to stop moving (1000ms for mechanical, higher for magnetic - depending on magnet strength)
      - delayed_off: 1000ms # Wait to start moving (1000ms for mechanical, higher for magnetic - depending on magnet strength)

  - platform: gpio
    id: closed_endstop
    name: "Closed Endstop"
    device_class: garage_door
    internal: true
    pin:
      number: D2
      mode: INPUT_PULLUP
    filters:
      - invert:
      - delayed_on: 1000ms # Wait to stop moving (1000ms for mechanical, higher for magnetic - depending on magnet strength)
      - delayed_off: 1000ms # Wait to start moving (1000ms for mechanical, higher for magnetic - depending on magnet strength)

cover:
  - platform: template
    name: "Carport Door"
    id: carport_door
    device_class: garage
    assumed_state: true
    lambda: !lambda |-
      if (id(closed_endstop).state)  // Door at closed endstop
      {
        if (id(carport_door).current_operation == esphome::cover::COVER_OPERATION_OPENING)  // We should be opening
        {
          if (!id(performing_last_movement))  // Make sure we don't trigger this logic twice otherwise it will do unwanted things
          {
            delay(1000);  // Wait for door to stop in case reed is triggered too early
            id(garage_door_relay).turn_on();  // Press button again
            id(performing_last_movement) = true;  // Set flag to indicate we madeknow where the door is
          }
        }
        else if (id(carport_door).current_operation == esphome::cover::COVER_OPERATION_CLOSING)
        {
          // We should be closing, so all is good
          id(performing_last_movement) = false;
          id(carport_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
          id(carport_door).position = COVER_CLOSED;
          id(carport_door).publish_state();
          return COVER_CLOSED;
        }
        else
        {
          // No operation in progress, just send state
          id(performing_last_movement) = false;
          if ((!id(carport_door).position) == esphome::cover::COVER_CLOSED)
          {
            id(carport_door).position = COVER_CLOSED;
            id(carport_door).publish_state();
            return COVER_CLOSED;
          }
        }
      }
      else if (id(open_endstop).state)  // Door at open endstop
      {
        if (id(carport_door).current_operation == esphome::cover::COVER_OPERATION_CLOSING)  // We should be closing
        {
          if (!id(performing_last_movement))  // Make sure we don't trigger this logic twice otherwise it will do unwanted things
          {
            delay(1000);  // Wait for door to stop in case reed is triggered too early
            id(garage_door_relay).turn_on();  // Press button again
            id(performing_last_movement) = true;  // Set flag to indicate we madeknow where the door is
          }
        }
        else if (id(carport_door).current_operation == esphome::cover::COVER_OPERATION_OPENING)
        {
          // We should be opening, so all is good
          id(performing_last_movement) = false;
          id(carport_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
          id(carport_door).position = COVER_OPEN;
          id(carport_door).publish_state();
          return COVER_OPEN;
        }
        else  // Door not at any endstop
        {
          // No operation in progress, just send state
          id(performing_last_movement) = false;
          if (id(carport_door).position != esphome::cover::COVER_OPEN)
          {
            id(carport_door).position = COVER_OPEN;
            id(carport_door).publish_state();
            return COVER_OPEN;
          }
        }
      }
      else
      {
        // The door is halfway open, so set it to OPEN
        if (id(carport_door).position != esphome::cover::COVER_OPEN)
        {
          id(carport_door).position = COVER_OPEN;
          id(carport_door).publish_state();
          return COVER_OPEN;
        }
      }
      return {};
    open_action:
      - lambda: !lambda |-
          id(carport_door).current_operation = esphome::cover::COVER_OPERATION_OPENING;
          if (!id(open_endstop).state) {
            id(garage_door_relay).turn_on();
            if (id(closed_endstop).state) {
              id(performing_last_movement) = true;  // Set flag to indicate we know where the door is
            }
          }
    close_action:
      - lambda: !lambda |-
          id(carport_door).current_operation = esphome::cover::COVER_OPERATION_CLOSING;
          if (!id(closed_endstop).state) {
            id(garage_door_relay).turn_on();
            if (id(open_endstop).state) {
              id(performing_last_movement) = true;  // Set flag to indicate we know where the door is
            }
          }
    stop_action:
      - lambda: !lambda |-
          if (id(carport_door).current_operation == esphome::cover::COVER_OPERATION_CLOSING ||
              id(carport_door).current_operation == esphome::cover::COVER_OPERATION_OPENING)
          {
            id(carport_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
            // Stop the door if it is moving
            id(performing_last_movement) = false;
            id(garage_door_relay).turn_on();
          }
